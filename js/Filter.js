import Flickity from "flickity";
import { findCommonElement } from "./helper";
import SubFilterBtn from "./SubFilterBtn.js";

/**
 * Creates the filter
 * Styling is done by scss
 */
class Filter {
  /**
   * static object that keeps track of all filters.
   * @type {{category: string, brand: Array, color:Array}}
   */
  static globalFilter = {
    category: "",
    brand: [],
    color: [],
  };

  static filterWalkieTalkie = [];
  static elementsPerPage = 20;
  static sortOption = "priceLH";

  /**
   * @property {HTMLref} ref points to where main filter location is in website
   * @property {function} generateFilterBtns adds event listeners to main category btns
   * @property {function} generateSubFilterBtns adds event listeners to sub category btns
   * @property {function} generateSorter adds event listeners to sorter options btn
   * @property {DOMarray} allProducts stores all products that were generated by PHP in dom array
   * @property {function} sortProducts launches sortProducts in order to have a max of X products on screen
   */
  constructor() {
    this.ref = document.querySelector(".filter__list");
    this.generateFilterBtns();
    this.generateSubFilterBtns();
    this.generateSorter();
    this.allProducts = document.querySelectorAll(".product-card");
    // way for subFilterBtns to communicate to Filter
    Filter.filterWalkieTalkie.push(this);
    this.sortProducts();
  }

  generateFilterBtns() {
    this.ref.querySelectorAll(".filter__item").forEach((element) => {
      element.addEventListener("click", (e) => {
        this.ref.querySelectorAll(".filter__item").forEach((element) => {
          element.classList.remove("active-filter");
        });
        e.target.classList.add("active-filter");

        Filter.globalFilter.category = e.target.dataset.filter;
        this.filterProducts();
      });
    });
  }

  generateSubFilterBtns = () => {
    document.querySelectorAll(".subfilter-btn").forEach((element) => {
      element.addEventListener("click", (e) => {
        if (e.target.nextElementSibling.classList.contains("hidden")) {
          document
            .querySelectorAll(".subfilter__selection")
            .forEach((element) => {
              element.classList.add("hidden");
            });
          e.target.nextElementSibling.classList.remove("hidden");
        } else {
          e.target.nextElementSibling.classList.add("hidden");
        }
      });
    });
    document.body.addEventListener("click", (e) => {
      if (
        !document
          .elementsFromPoint(e.clientX, e.clientY)
          .find((x) => x.classList.contains("subfilter__selection")) &&
        !e.target.classList.contains("general-subfilter-btn")
      ) {
        document
          .querySelectorAll(".subfilter__selection")
          .forEach((element) => {
            element.classList.add("hidden");
          });
      }
    });

    document
      .querySelector(".subfilter-btn-clear")
      .addEventListener("click", this.clearFilters);
    document
      .querySelector(".subfilter__clear-color")
      .addEventListener("click", this.clearColors);
    document
      .querySelector(".subfilter__clear-brand")
      .addEventListener("click", this.clearBrands);
    document.querySelectorAll(".color-checkbox").forEach((element) => {
      element.addEventListener("change", this.subFilter);
      element.addEventListener("change", this.toggleActiveColorBtn);
    });
    document.querySelectorAll(".brand-checkbox").forEach((element) => {
      element.addEventListener("change", this.subFilter);
      element.addEventListener("change", this.toggleActiveBrandBtn);
    });
    // CHANGE TO SINGLE CHECKBOX CLASS?
  };

  /**
   * @property {function} clearFilters
   * clears all checkboxes <br>
   * clear globalFilter <br>
   * close all open subfilter options <br>
   * close all open subfilter options <br>
   * delete all dom elements (by looping over activefilters within SubfilterBtn class and evoke delete()) <br>
   * Finally filters products again
   *
   * @returns {void}
   */
  clearFilters = () => {
    // Clearing checkboxes
    document.querySelectorAll(".color-checkbox").forEach((element) => {
      if (element.checked) {
        element.checked = false;
      }
    });
    document.querySelectorAll(".brand-checkbox").forEach((element) => {
      if (element.checked) {
        element.checked = false;
      }
    });
    // Clearing globalFilter
    Filter.globalFilter.color = [];
    Filter.globalFilter.brand = [];
    // close all
    document.querySelectorAll(".subfilter__selection").forEach((element) => {
      element.classList.add("hidden");
    });
    // Delete all SubfilterBtn DOM elements
    for (const key in SubFilterBtn.activeFilters) {
      SubFilterBtn.activeFilters[key].forEach((element) => {
        element.delete();
      });
    }
    // Filter products
    this.filterProducts();
  };

  /**
   * @property {function} clearColors
   * Same functionality as clearFilters but only for colors
   * @returns {void}
   */
  clearColors = () => {
    // All checkboxes on false colors
    document.querySelectorAll(".color-checkbox").forEach((element) => {
      if (element.checked) {
        element.checked = false;
      }
    });
    // Delete all activeFilter btns colors
    SubFilterBtn.activeFilters.colors.forEach((element) => {
      element.delete();
    });
    // Empty GlobalFilter color
    Filter.globalFilter.color = [];
    // Run filter
    this.filterProducts();
  };
  /**
   * @property {function} clearBrands
   * Same functionality as clearFilters and clearColors but only for colors
   * @returns {void}
   */
  clearBrands = () => {
    // All checkboxes on false brands
    document.querySelectorAll(".brand-checkbox").forEach((element) => {
      if (element.checked) {
        element.checked = false;
      }
    });
    // Delete all activeFilter btns brands
    SubFilterBtn.activeFilters.brands.forEach((element) => {
      element.delete();
    });
    // Empty GlobalFilter brand
    Filter.globalFilter.brand = [];
    // run filter
    this.filterProducts();
  };
  /**
   * @property {function} toggleActiveColorBtn
   * toggles this specific filter Btn on or off <br>
   * checks whether e.target is checked. <br>
   * If yes -> new SubFilterBtn <br>
   * If no -> find this Btn in activeFilters and call delete().
   * @returns {void}
   */
  toggleActiveColorBtn = (e) => {
    if (e.target.checked) {
      // In fact SubFilterBtn class should choose where to put new btn.

      new SubFilterBtn(e.target.id, e.target.nextElementSibling.innerHTML);
    } else {
      const targetId = e.target.id;
      // Delete div from DOM
      SubFilterBtn.activeFilters.colors.find((x) => x.id == targetId).delete();
    }
  };
  /**
   * @property {function} toggleActiveBrandBtn
   * Same functionality as toggleColorBtn but for brands
   * @returns {void}
   */
  toggleActiveBrandBtn = (e) => {
    if (e.target.checked) {
      new SubFilterBtn(e.target.id, e.target.nextElementSibling.innerHTML);
    } else {
      const targetId = e.target.id;
      // Delete div from DOM
      SubFilterBtn.activeFilters.brands.find((x) => x.id == targetId).delete();
    }
  };

  /**
   * @property {function} subFilter
   * Loops over checked and unchecked checkboxes of both Color and Brand and alters GlobalFilter accordingly <br>
   * Then it calls filterProducts function
   * @returns {void}
   */
  subFilter = () => {
    // Colors
    Filter.globalFilter.color = [];
    document.querySelectorAll(".color-checkbox").forEach((element) => {
      if (element.checked) {
        Filter.globalFilter.color.push(element.id);
      }
    });
    // Brands
    Filter.globalFilter.brand = [];
    document.querySelectorAll(".brand-checkbox").forEach((element) => {
      if (element.checked) {
        Filter.globalFilter.brand.push(element.id);
      }
    });
    this.filterProducts();

    // Price
  };

  /**
   * @property {function} filterProducts
   * For all filters (color, brand, main category), it add or removes "hidden" class according to info in globalFilter object <br>
   * Then it call sortProducts -> this step is still unsure
   * @returns {void}
   */
  filterProducts = () => {
    this.allProducts.forEach((element) => {
      element.classList.remove("hidden");
      // brand
      if (Filter.globalFilter.brand.length > 0) {
        if (!Filter.globalFilter.brand.includes(element.dataset.brand)) {
          element.classList.add("hidden");
        }
      }
      // colors -> check if arrays overlap
      if (Filter.globalFilter.color.length > 0) {
        const productColors = element.dataset.color.split(",");
        if (!findCommonElement(productColors, Filter.globalFilter.color)) {
          element.classList.add("hidden");
        }
      }
      // category
      if (Filter.globalFilter.category != "") {
        if (element.dataset.category != Filter.globalFilter.category) {
          element.classList.add("hidden");
        }
      }
    });
    this.sortProducts();
  };

  generateSorter() {
    document
      .querySelector(".testBtn")
      .addEventListener("click", this.sortProducts);
  }

  /**
   * @property {function} sortProducts
   * Checks global sortOption (either standard one or chosen by user) and sorts allProducts array accordingly <br>
   * inserts HTML in this order. <br>
   * It has a standard max of products shows on page. This can be increased by user.
   * @returns {void}
   */
  sortProducts = () => {
    // this way works but as it always empties html en fills again, it tends to be wonky
    // certainly at startup, it should be smooth
    // Although it doesnt matter as first screen is keyboard

    if (Filter.sortOption === "priceLH") {
      this.allProducts = [].slice.call(this.allProducts).sort(function (a, b) {
        return parseInt(a.dataset.price) >= parseInt(b.dataset.price) ? 1 : -1;
      });
    } else if (Filter.sortOption === "priceHL") {
      this.allProducts = [].slice.call(this.allProducts).sort(function (a, b) {
        return parseInt(a.dataset.price) <= parseInt(b.dataset.price) ? 1 : -1;
      });
    }

    let counter = 0;
    document.querySelector(".grid-container").innerHTML = "";
    this.allProducts.forEach((element) => {
      if (
        !element.classList.contains("hidden") &&
        counter < Filter.elementsPerPage
      ) {
        document
          .querySelector(".grid-container")
          .insertAdjacentElement("beforeend", element);
        counter++;
      }
    });
  };
  /*
    If counter <= elementsPerPage -> all products are shown so "show more" not needed

  */
}

export default Filter;
